"""
Primitive SDF Shapes
====================

This module provides basic geometric primitive SDFs that can be used as building
blocks for more complex geometries. All primitives inherit from SDFBase and can
be combined using boolean operations.

Available Primitives
--------------------
- SphereSDF: Sphere with specified center and radius
- CylinderSDF: Infinite cylinder along a coordinate axis
- TorusSDF: Torus with major and minor radii
- PlaneSDF: Half-space defined by a point and normal vector
- CornerSpheresSDF: Cube with spherical cutouts at corners
- CrossMsSDF: Cross-shaped structure (intersection of three cylinders)

All primitives support PyTorch's automatic differentiation and can be used
in optimization workflows.
"""

from DeepSDFStruct.SDF import SDFBase
import torch


class SphereSDF(SDFBase):
    """Signed distance function for a sphere.

    Computes the signed distance from query points to a sphere surface.
    The distance is negative inside the sphere, zero on the surface,
    and positive outside.

    Parameters
    ----------
    center : array-like of shape (3,)
        Center point of the sphere in 3D space.
    radius : float
        Radius of the sphere.

    Examples
    --------
    >>> import torch
    >>> from DeepSDFStruct.sdf_primitives import SphereSDF
    >>>
    >>> sphere = SphereSDF(center=[0, 0, 0], radius=1.0)
    >>> points = torch.tensor([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]])
    >>> distances = sphere(points)
    >>> print(distances)  # [-1.0, 0.0] (center, surface)
    """

    def __init__(self, center, radius):
        super().__init__()
        # make center and radius trainable parameters and ensure correct dtype
        c = torch.as_tensor(center, dtype=torch.float32)
        r = torch.as_tensor(radius, dtype=torch.float32)
        self.center = torch.nn.Parameter(c)
        self.r = torch.nn.Parameter(r.reshape(()))  # scalar parameter

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        # ensure computations use same dtype/device as queries
        center = self.center.to(device=queries.device, dtype=queries.dtype)
        r = self.r.to(device=queries.device, dtype=queries.dtype)
        return (torch.linalg.norm(queries - center, dim=1) - r).reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


class CylinderSDF(SDFBase):
    """Signed distance function for an infinite cylinder.

    Creates a cylinder extending infinitely along a specified coordinate axis.
    The cylinder is defined by a point on the axis and a radius.

    Parameters
    ----------
    point : array-like of shape (3,)
        A point on the cylinder's axis.
    axis : str or int
        Axis direction: 'x'/0, 'y'/1, or 'z'/2.
    radius : float
        Radius of the cylinder.

    Examples
    --------
    >>> from DeepSDFStruct.sdf_primitives import CylinderSDF
    >>> import torch
    >>>
    >>> # Cylinder along z-axis
    >>> cylinder = CylinderSDF(point=[0, 0, 0], axis='z', radius=0.5)
    >>> points = torch.tensor([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]])
    >>> distances = cylinder(points)
    >>> print(distances)  # [-0.5, 0.5] (on axis, outside)
    """

    def __init__(self, point, axis, radius):
        super().__init__()
        self.point = torch.tensor(point, dtype=torch.float32)
        self.axis = axis
        self.r = radius

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        diff = queries - self.point
        if self.axis == "x" or self.axis == 0:
            dist = torch.sqrt(diff[:, 1] ** 2 + diff[:, 2] ** 2)
        elif self.axis == "y" or self.axis == 1:
            dist = torch.sqrt(diff[:, 0] ** 2 + diff[:, 2] ** 2)
        elif self.axis == "z" or self.axis == 2:
            dist = torch.sqrt(diff[:, 0] ** 2 + diff[:, 1] ** 2)
        else:
            raise ValueError(
                "Axis must be either ['x', 'y','z'] or [0, 1, 2]." f" got {self.axis}"
            )
        return (dist - self.r).reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


class TorusSDF(SDFBase):
    """Signed distance function for a torus.

    A torus is a surface of revolution generated by revolving a circle
    (minor radius) around an axis at a specified distance (major radius).

    Parameters
    ----------
    center : array-like of shape (3,)
        Center point of the torus in 3D space.
    R : float
        Major radius (distance from torus center to tube center).
    r : float
        Minor radius (radius of the tube).

    Examples
    --------
    >>> from DeepSDFStruct.sdf_primitives import TorusSDF
    >>> import torch
    >>>
    >>> torus = TorusSDF(center=[0, 0, 0], R=1.0, r=0.3)
    >>> points = torch.tensor([[1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])
    >>> distances = torus(points)
    """

    def __init__(self, center, R, r):
        super().__init__()
        self.center = torch.tensor(center, dtype=torch.float32)
        self.R = R
        self.r = r

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        p = queries - self.center
        q = torch.stack(
            [torch.sqrt(p[:, 0] ** 2 + p[:, 1] ** 2) - self.R, p[:, 2]], dim=1
        )
        dist = torch.linalg.norm(q, dim=1) - self.r
        return dist.reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


class PlaneSDF(SDFBase):
    def __init__(self, point, normal):
        super().__init__()
        self.point = torch.tensor(point, dtype=torch.float32)
        self.normal = torch.tensor(normal, dtype=torch.float32)
        self.normal = self.normal / torch.linalg.norm(self.normal)

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        return torch.matmul(queries - self.point, self.normal).reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


class CornerSpheresSDF(SDFBase):
    def __init__(self, radius, limit=1.0):
        super().__init__()
        self.r = radius
        self.limit = limit

        # define the 8 corners of the cube
        self.corners = torch.tensor(
            [[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]],
            dtype=torch.float32,
        )

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:

        # start with the cube SDF
        output = torch.linalg.norm(queries, dim=1, ord=float("inf")) - self.limit

        # subtract spheres at corners
        for corner in self.corners:
            sphere_like = torch.linalg.norm(queries - corner, dim=1, ord=3) - self.r
            output = torch.maximum(output, -sphere_like)

        return output.reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


class CrossMsSDF(SDFBase):
    def __init__(self, radius):
        super().__init__()
        self.r = radius

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        # start with the Lâˆž norm
        output = torch.linalg.norm(queries, dim=1, ord=float("inf"))

        # x-axis cylinder
        cylinder_x = torch.sqrt(queries[:, 1] ** 2 + queries[:, 2] ** 2) - self.r
        output = torch.minimum(output, cylinder_x)

        # y-axis cylinder
        cylinder_y = torch.sqrt(queries[:, 0] ** 2 + queries[:, 2] ** 2) - self.r
        output = torch.minimum(output, cylinder_y)

        # z-axis cylinder
        cylinder_z = torch.sqrt(queries[:, 0] ** 2 + queries[:, 1] ** 2) - self.r
        output = torch.minimum(output, cylinder_z)

        return output.reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])


# New 2D primitives: CircleSDF and RectangleSDF
class CircleSDF(SDFBase):
    """2D circle SDF (geometric_dim=2). Center and radius are torch parameters."""

    def __init__(self, center, radius):
        super().__init__(geometric_dim=2)
        c = torch.as_tensor(center, dtype=torch.float32)
        r = torch.as_tensor(radius, dtype=torch.float32)
        if c.numel() != 2:
            raise ValueError("center must be length-2 for CircleSDF")
        self.center = torch.nn.Parameter(c.reshape(2))
        self.radius = torch.nn.Parameter(r.reshape(()))

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        # queries expected shape (N,2)
        if queries.shape[1] == 3:
            queries = queries[:, :2]
        center = self.center.to(device=queries.device, dtype=queries.dtype)
        r = self.radius.to(device=queries.device, dtype=queries.dtype)
        return (torch.linalg.norm(queries - center, dim=1) - r).reshape(-1, 1)

    def _get_domain_bounds(self) -> torch.Tensor:
        return torch.tensor([[-1.0, -1.0], [1.0, 1.0]])


class RectangleSDF(SDFBase):
    """2D axis-aligned rectangle SDF. half_extents defines half-widths in x and y.
    Both center and half_extents are torch parameters.
    SDF computed using standard box SDF formula in 2D.
    """

    def __init__(self, center, extents):
        super().__init__(geometric_dim=2)
        c = torch.as_tensor(center, dtype=torch.float32)
        h = torch.as_tensor(extents, dtype=torch.float32)
        if c.numel() != 2 or h.numel() != 2:
            raise ValueError(
                "center and half_extents must be length-2 for RectangleSDF"
            )
        self.center = torch.nn.Parameter(c.reshape(2))
        self.extents = torch.nn.Parameter(h.reshape(2))

    def _compute(self, queries: torch.Tensor) -> torch.Tensor:
        center = self.center.to(device=queries.device, dtype=queries.dtype)
        half = self.extents.to(device=queries.device, dtype=queries.dtype) / 2
        if queries.shape[1] == 3:
            queries = queries[:, :2]
        q = queries - center  # (N,2)
        d = torch.abs(q) - half  # (N,2)
        # outside distance
        zero = torch.tensor(0.0, device=queries.device, dtype=queries.dtype)
        d_clamped = torch.maximum(d, zero)
        outside_dist = torch.linalg.norm(d_clamped, dim=1)
        # inside distance (negative when inside)
        inside_dist = torch.minimum(torch.maximum(d[:, 0], d[:, 1]), zero)
        sdf = (outside_dist + inside_dist).reshape(-1, 1)
        return sdf

    def _get_domain_bounds(self) -> torch.Tensor:
        center = self.center.detach()
        half = self.extents.detach() / 2.0

        lower = center - half
        upper = center + half

        return torch.stack([lower, upper], dim=0)
